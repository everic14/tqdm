# scikit-learn tqdm Integration Roadmap
### Background
tqdm is a progress bar in Python.  See more information on the tqdm website ‚û° https://tqdm.github.io/.  Currently tqdm has integration with pandas, concurrent.futures, itertools.product, keras, and telegram.  **This project aims to add scikit-learn to the previous list by integrating tqdm with scikit-learn as much as possible.**
<!-- What the hell is telegram lol? -->
### Why implement tqdm with scikit-learn?
scikit-learn is a popular package for training machine learning models (known as "estimators" in scikit-learn lexicon).  Currently in scikit-learn there are no good ways of knowing when the estimators will finish training other than poorly implemented verbose (print) indicators in joblib and in scikit-learn itself.  tqdm integration will allow users to have a good approximation of when there estimators will be finished training, which of course is very useful, especially for long training durations.

### Challenges of implementing tqdm with scikit-learn
scikit-learn has a lot of estimators in its ecosystem and each estimator will most likely need a custom-tailored approach to measure progress.  This makes this project quite difficult because there over a dozen different categories of estimators, which does not even take in to account the variations of each estimator category (e.g. [`neighbors`](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.neighbors) is a category while [`KNeighborsClassifier`](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier) is a variation of the estimator category).  Additionally some estimators vary where they take a lot of computation.  For example, some estimators require lots of computation during the training phase (fit method) while other estimators require lots of computation during the testing phase (predict method).  This would directly impact the implementation of tqdm for every estimator (because tqdm is most useful when measuring long amounts of computation).  On top of all this there are even more ways to mix and match estimators, with tools such as model selection, which expands the ways tqdm will need to be implemented.

### Where to start with implementation
Since there are so many conditions and scenarios to consider in this project, it is best to start simple.  *For now*, development of this project will only be with latest version of scikit-learn.  The first stage of implementation will start with the various functions in the model selection portion of scikit-learn.  First, the project will focus on the `cross_val_predict` function in scikit-learn.

### `cross_val_predict` function implementation
When implementing tqdm with the `cross_val_predict` function there are two possible ways to measure progress.  **Option 1 is to measure how many folds** *(aka the 'cv' keyword argument)* **have been completed.**  Option 1 is ideally to be avoided.  Option 1 has many drawbacks, most notably that updates on progress are entirely dependent on how many folds there are.  The fewer folds the less frequent updates on progress are.  Although this is better than the current verbose system (mentioned above) it is only marginally better.  **Option 2 is to measure the progress of the estimator itself.  This would measure either the amount of data the estimator has 'learned' or the amount of data the estimator has predicted**, depending on which operation is more time consuming.  Option 2 would provide a very precise measure of progress as every time data is either learned or predicted the progress bar would update.  Awesome!  However, there are limitations of Option 2.  Option 2 requires much more work to implement than Option 1.  And like alluded to above, every estimator will need to have a custom-tailored implementation of progress when using Option 2.  And in some instances (e.g. nearest-neighbors with a KD Tree) inserting the `tqdm.update` method is extremely difficult, due to the nature of the computation.  For example, nearest-neighbors with a KD tree uses numpy vectorization during the computation process which makes it quite difficult to insert the `tqdm.update` function (although a workaround is currently being researched).  Additionally, Option 2 can *drastically* increase computation time in some select cases.  For example, when using nearest-neighbors, replacing the native Euclidean distance computation function with a Euclidean distance function with the `tqdm.update` method increase the computation by *orders of magnitude* (exactly difference in times will come soon).

In conclusion, the first stepping stone for the project is to make as many estimators work with the `cross_val_predict` function.  Then other goals of the project will be outlined.

### Things to keep in the mind for the future (Informal)
* Your going to need to implement this for as many versions of scikit-learn as possible (maybe not the super early versions but IDK)
* Testing!!! This is going to be super important.  Test on as many systems as possible!  Whether it be Mac, Windows, or Linux.  Test everything everywhere!
* On the testing subject, look into the tests included in the tqdm github, don't really know what those are about but good to keep in mind for the future
* See what you can do to implement tqdm no matter how the computation is being done in fit/predict methods. IK that there are some crazy computational tricks going on in the euclidean function of scikit-learn, so decode that and see what u can do without *tanking* computational time.
* Once the `cross_val_predict` function is implemented hopefully it will be relatively easy to implement all the other `model_selection` functions will be relatively easy to implement
* It's gonna be interesting to see how your going to communicate the lower level `fit`/`predict` functions with the upper level `cross_val_predict` function
* Your probably going to need to learn every estimator in scikit-learn really well so yeah.
* Take inspiration from the `tqdm.pandas` implementation.  Very well done üëè
* Probably want to work in another file so everything isn't so cluttered but don't know whether or not in the final version everything will remain in that separate file so that will need to be determined
